//------------------------------------------------------------------------------
// <auto-generated>
//     此代码由工具生成。
//     运行时版本:4.0.30319.18444
//
//     对此文件的更改可能会导致不正确的行为，并且如果
//     重新生成代码，这些更改将会丢失。
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Threading;
using UnityEngine;

namespace GameBase
{
	public class TimerManager
	{
		public TimerManager (float fTick,int nMaxTickCount,int nHeapCount)
		{
			m_fTick = fTick;
			m_nMaxTickCount = nMaxTickCount;
			m_nHeapCount = nHeapCount;
			m_timerHeapList = new MinHeap<TimerWrapper>[nHeapCount];
			m_heapLockList = new ReaderWriterLock[nHeapCount];
		}
		public void Update()
		{
			while(m_nDirtyHeap == m_nCurrentHeap)
			{
				//to do;
				m_nDirtyHeap++;
			}

		}
		private void SetTime(float fDelta)
		{
			m_rwLock.AcquireWriterLock(0);
			try
			{
				m_fDelta += fDelta;
				int nTickCount = (int)(m_fDelta/m_fTick);
				m_fDelta -= (float)nTickCount*m_fTick;
				m_nTickCount += nTickCount;
				m_nDirtyHeap = m_nCurrentHeap;
				m_nCurrentHeap = (m_nTickCount+nTickCount)%m_nHeapCount;
			}
			finally
			{
				m_rwLock.ReleaseWriterLock();
			}
		}
		public void AddTimer(Timer timer)
		{
			m_rwLock.AcquireReaderLock(0);
			try
			{
				TimerWrapper wrapper = new TimerWrapper(timer,m_nMaxTickCount,m_fTick);
				m_heapLockList[m_nCurrentHeap + wrapper.m_nGroupCount].AcquireWriterLock(0);
				try
				{
					m_timerHeapList[m_nCurrentHeap + wrapper.m_nGroupCount].Insert(wrapper);
				}
				finally
				{
					m_heapLockList[m_nCurrentHeap + wrapper.m_nGroupCount].ReleaseWriterLock();
				}
			}
			finally
			{
				m_rwLock.ReleaseReaderLock();
			}
		}
		private float m_fDelta = 0;
		private float m_fTick;
		private int m_nHeapCount;
		private int m_nTickCount;
		private int m_nMaxTickCount;
		private MinHeap<TimerWrapper>[] m_timerHeapList;
		private ReaderWriterLock[] m_heapLockList;
		private int m_nCurrentHeap = 0;
		private int m_nDirtyHeap = 0;
		private ReaderWriterLock m_rwLock = new ReaderWriterLock();
	}
}

